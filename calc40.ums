################################################################################
#
#                      calc40.ums
#
#     Assignment: Assembly-Language Programming
#     Authors:    Julian DuTemple (jdutem01), Tanner Vales (tvales01)
#     Date:       2025-12-08
#
#     Summary:
#       RPN calculator implementation in UMASM. Handles the main event loop,
#       digit entry state machine, stack manipulation, and arithmetic
#       operations.
#
#     Calling convention:
#       r0 = 0
#       r1 = return address / result / scratch
#       r2 = call stack pointer
#       r3, r4 nonvolatile (r4 = value stack pointer)
#       r5, r6, r7 volatile (r6, r7 reserved for assembler temps)
#
#     Value stack:
#       Stored in array values[10000] in segment 0.
#       r4 is the value-stack pointer; stack grows downward.
#
################################################################################

################################################################################
#                           Data + Jump Table Storage
################################################################################
.temps r6, r7
.zero r0

.section data
values:
        .space 10000
values_end:

.section rodata
jumptable:
        .space 256

################################################################################
#                           Helper Routines (text)
################################################################################
.section text

# ********** underflow **********
#
# Print an error message indicating stack underflow and the number of elements
# expected.
#
# Parameters:
#       r5: The number of elements expected (integer).
#
# Return:
#       None (void).
#
# Expects:
#       r5 contains a valid integer. r1 contains return address.
#
# Notes:
#       Prints "Stack underflow---expected at least N element(s)\n".
#       Handles pluralization of "element" vs "elements".
# *******************************
underflow:
        push r1 on stack r2
        push r5 on stack r2     # Save n (r5) because print_word clobbers it

        # Print "Stack underflow---expected at least "
        output 'S'; output 't'; output 'a'; output 'c'; output 'k'
        output ' '; output 'u'; output 'n'; output 'd'; output 'e'
        output 'r'; output 'f'; output 'l'; output 'o'; output 'w'
        output '-'; output '-'; output '-'
        output 'e'; output 'x'; output 'p'; output 'e'; output 'c'
        output 't'; output 'e'; output 'd'; output ' '; output 'a'
        output 't'; output ' '; output 'l'; output 'e'; output 'a'
        output 's'; output 't'; output ' '

        # r5 holds n. Print it.
        goto print_word linking r1

        # Print " element"
        output ' '; output 'e'; output 'l'; output 'e'; output 'm'
        output 'e'; output 'n'; output 't'

        # Restore n to check for plural
        pop r5 off stack r2

        r3 := 1
        # Check if n == 1.
        # Use r1 as scratch; real return address is safe on the stack.
        if (r5 == r3) goto uf_done using r1

        output 's'

uf_done:
        output '\n'
        pop r1 off stack r2
        goto r1

# ********** check1 **********
#
# Ensure there is at least 1 value on the value stack.
#
# Parameters:
#       None.
#
# Return:
#       Returns to caller if check passes.
#       Does NOT return if check fails (jumps to waiting loop).
#
# Expects:
#       r4 is the value stack pointer.
#       r1 is the return address.
# ****************************
check1:
        push r3 on stack r2
        r3 := r4
        r3 := r3 nand r3
        r5 := 1
        r3 := r3 + r5
        r5 := values_end
        r3 := r3 + r5

        # using r5 as temp
        if (r3 <s 1) goto c1_fail using r5

        pop r3 off stack r2
        goto r1

c1_fail:
        pop r3 off stack r2
        r5 := 1
        goto underflow linking r1
        goto waiting

# ********** check2 **********
#
# Ensure there are at least 2 values on the value stack.
#
# Parameters:
#       None.
#
# Return:
#       Returns to caller if check passes.
#       Does NOT return if check fails (jumps to waiting loop).
#
# Expects:
#       r4 is the value stack pointer.
#       r1 is the return address.
# ****************************
check2:
        push r3 on stack r2
        r3 := r4
        r3 := r3 nand r3
        r5 := 1
        r3 := r3 + r5
        r5 := values_end
        r3 := r3 + r5

        # using r5 as temp
        if (r3 <s 2) goto c2_fail using r5

        pop r3 off stack r2
        goto r1

c2_fail:
        pop r3 off stack r2
        r5 := 2
        goto underflow linking r1
        goto waiting

# ********** print_stack **********
#
# Print all values currently on the value stack.
#
# Parameters:
#       None.
#
# Return:
#       None.
#
# Expects:
#       r4 points to the top of the value stack.
# *********************************
print_stack:
        push r1 on stack r2
        push r3 on stack r2
        push r4 on stack r2
        push r5 on stack r2

        r3 := r4                # r3 = current pointer

ps_loop:
        r5 := values_end

        # r3==r5 needs extra scratch registers.
        # r1 is currently garbage (saved on stack), so it is safe to use.
        if (r3 == r5) goto ps_done using r1

        r5 := m[r0][r3]
        output '>'; output '>'; output '>'; output ' '
        goto print_word linking r1
        output '\n'
        r3 := r3 + 1
        goto ps_loop

ps_done:
        pop r5 off stack r2
        pop r4 off stack r2
        pop r3 off stack r2
        pop r1 off stack r2
        goto r1

# ********** input_error **********
#
# Handle invalid input characters.
#
# Parameters:
#       r1: The invalid character.
#
# Return:
#       Does not return to caller; jumps to waiting loop.
# *********************************
input_error:
        push r1 on stack r2
        output 'U'; output 'n'; output 'k'; output 'n'; output 'o'
        output 'w'; output 'n'
        output ' '; output 'c'; output 'h'; output 'a'; output 'r'
        output 'a'; output 'c'; output 't'; output 'e'; output 'r'
        output ' '
        r3 := 39
        output r3
        pop r5 off stack r2
        output r5
        output r3
        output '\n'
        goto waiting

################################################################################
#                           Operator Handlers
################################################################################

# ********** digit_waiting **********
#
# Handle digit input while in the waiting state. Pushes the digit value
# and transitions to the entering state.
#
# Parameters:
#       r1: The digit character ('0'..'9').
# ***********************************
digit_waiting:
        r3 := '0'
        r3 := r3 nand r3
        r5 := 1
        r3 := r3 + r5
        r5 := r1 + r3
        push r5 on stack r4
        goto entering

# ********** Operators **********
# Each operator pops arguments from r4, performs the operation, and pushes
# result back to r4. Returns to waiting state.
# *******************************

op_newline:
        goto print_stack linking r1
        goto waiting

op_add:
        goto check2 linking r1
        pop r1 off stack r4
        pop r5 off stack r4
        r5 := r5 + r1
        push r5 on stack r4
        goto waiting

op_sub:
        goto check2 linking r1
        pop r1 off stack r4
        pop r5 off stack r4
        r1 := r1 nand r1
        r3 := 1
        r1 := r1 + r3
        r5 := r5 + r1
        push r5 on stack r4
        goto waiting

op_mul:
        goto check2 linking r1
        pop r1 off stack r4
        pop r5 off stack r4
        r5 := r5 * r1
        push r5 on stack r4
        goto waiting

op_bor:
        goto check2 linking r1
        pop r1 off stack r4
        pop r5 off stack r4

        # x | y = ~(~x & ~y)
        r3 := r5 nand r5        # r3 = ~x
        r1 := r1 nand r1        # r1 = ~y
        r5 := r3 nand r1        # r5 = ~(~x & ~y) = x | y

        push r5 on stack r4
        goto waiting

op_band:
        goto check2 linking r1
        pop r1 off stack r4
        pop r5 off stack r4
        r5 := r5 nand r1
        r5 := r5 nand r5
        push r5 on stack r4
        goto waiting

op_bnot:
        goto check1 linking r1
        pop r5 off stack r4
        r5 := r5 nand r5
        push r5 on stack r4
        goto waiting

op_csign:
        goto check1 linking r1
        pop r5 off stack r4
        r5 := r5 nand r5
        r3 := 1
        r5 := r5 + r3
        push r5 on stack r4
        goto waiting

op_swap:
        goto check2 linking r1
        pop r1 off stack r4
        pop r5 off stack r4
        push r1 on stack r4
        push r5 on stack r4
        goto waiting

op_dup:
        goto check1 linking r1
        pop r5 off stack r4
        push r5 on stack r4
        push r5 on stack r4
        goto waiting

op_pop:
        goto check1 linking r1
        pop r5 off stack r4
        goto waiting

op_clear:
        r4 := values_end
        goto waiting

op_div:
        goto check2 linking r1
        pop r1 off stack r4     # y
        pop r5 off stack r4     # x

        if (r1 == 0) goto div_zero

        r3 := 0x80000000

        push r5 on stack r2
        push r1 on stack r2

        r5 := r5 & r3
        if (r5 == 0) goto x_nonneg

        pop r1 off stack r2
        pop r5 off stack r2
        push r5 on stack r2
        push r1 on stack r2

        r1 := r1 & r3
        if (r1 == 0) goto div_x_neg_only

        pop r1 off stack r2
        pop r5 off stack r2
        r5 := r5 nand r5; r3 := 1; r5 := r5 + r3
        r1 := r1 nand r1; r3 := 1; r1 := r1 + r3
        r5 := r5 / r1
        push r5 on stack r4
        goto waiting

x_nonneg:
        pop r1 off stack r2
        pop r5 off stack r2
        push r5 on stack r2
        push r1 on stack r2

        r1 := r1 & r3
        if (r1 == 0) goto div_both_nonneg

        pop r1 off stack r2
        pop r5 off stack r2
        r1 := r1 nand r1; r3 := 1; r1 := r1 + r3
        r5 := r5 / r1
        r5 := r5 nand r5; r3 := 1; r5 := r5 + r3
        push r5 on stack r4
        goto waiting

div_both_nonneg:
        pop r1 off stack r2
        pop r5 off stack r2
        r5 := r5 / r1
        push r5 on stack r4
        goto waiting

div_x_neg_only:
        pop r1 off stack r2
        pop r5 off stack r2
        r5 := r5 nand r5; r3 := 1; r5 := r5 + r3
        r5 := r5 / r1
        r5 := r5 nand r5; r3 := 1; r5 := r5 + r3
        push r5 on stack r4
        goto waiting

div_zero:
        output 'D'; output 'i'; output 'v'; output 'i'; output 's'
        output 'i'; output 'o'; output 'n'
        output ' '; output 'b'; output 'y'; output ' '; output 'z'
        output 'e'; output 'r'; output 'o'
        output '\n'
        push r5 on stack r4
        push r1 on stack r4
        goto waiting

################################################################################
#                           Main Calculator FSM
################################################################################

# ********** main **********
#
# Entry point for the calculator loop. Initializes stack pointer and
# enters the waiting loop.
#
# Expects:
#       r2 is call stack pointer.
#       r0 is zero.
# **************************
main:
        # Save the return address (r1) to the call stack (r2)
        # r1 holds the address of the 'halt' instruction from callmain.ums
        push r1 on stack r2

        r4 := values_end
        goto waiting

waiting:
        r1 := input()

waiting_with_character:
        # r5 is safe to use as temp here
        if (r1 == -1) goto calc_done using r5
        r5 := jumptable + r1
        r5 := m[r0][r5]
        goto r5

entering:
        r1 := input()
        r3 := '0'
        if (r1 <s r3) goto entering_not_digit using r5
        r3 := '9'
        if (r1 >s r3) goto entering_not_digit using r5

        # Save r1 (digit char) because 'linking r1' clobbers it!
        push r1 on stack r2

        goto check1 linking r1

        # Restore r1 (digit char)
        pop r1 off stack r2

        # Get current number from value stack
        pop r5 off stack r4

        # Multiply current by 10
        r3 := 10
        r5 := r5 * r3

        # Calculate digit value: r1 - '0'
        r3 := '0'
        r3 := r3 nand r3      # r3 = ~'0'

        # We need to add 1 to r3 to get -'0'.
        # Save accumulator r5 to use r5 as temp.
        push r5 on stack r2
        r5 := 1
        r3 := r3 + r5         # r3 = -'0'
        pop r5 off stack r2   # Restore accumulator

        r3 := r1 + r3         # r3 = char - '0'
        r5 := r5 + r3         # New value = (old * 10) + digit

        push r5 on stack r4
        goto entering

entering_not_digit:
        goto waiting_with_character

calc_done:
        # Restore the return address (r1) from the call stack
        pop r1 off stack r2
        goto r1

################################################################################
#                           Initialize Jump Table (init)
################################################################################
.section init

        r5 := 0
        r3 := jumptable

jt_fill_loop:
        # using r1, r4 because signed comparisons are expensive.
        if (r5 <s 256) goto jt_fill_body using r1, r4
        goto jt_fill_done

jt_fill_body:
        m[r0][r3] := input_error
        r3 := r3 + 1
        r5 := r5 + 1
        goto jt_fill_loop

jt_fill_done:
        r5 := '0'

digit_jt_loop:
        # using r1, r4
        if (r5 >s '9') goto digit_jt_done using r1, r4
        r3 := jumptable
        r3 := r3 + r5
        m[r0][r3] := digit_waiting
        r5 := r5 + 1
        goto digit_jt_loop

digit_jt_done:
        r5 := jumptable + ' '
        m[r0][r5] := waiting
        r5 := jumptable + '\n'
        m[r0][r5] := op_newline
        r5 := jumptable + '+'
        m[r0][r5] := op_add
        r5 := jumptable + '-'
        m[r0][r5] := op_sub
        r5 := jumptable + '*'
        m[r0][r5] := op_mul
        r5 := jumptable + '/'
        m[r0][r5] := op_div
        r5 := jumptable + '&'
        m[r0][r5] := op_band
        r5 := jumptable + '|'
        m[r0][r5] := op_bor
        r5 := jumptable + '~'
        m[r0][r5] := op_bnot
        r5 := jumptable + 'c'
        m[r0][r5] := op_csign
        r5 := jumptable + 's'
        m[r0][r5] := op_swap
        r5 := jumptable + 'd'
        m[r0][r5] := op_dup
        r5 := jumptable + 'p'
        m[r0][r5] := op_pop
        r5 := jumptable + 'z'
        m[r0][r5] := op_clear